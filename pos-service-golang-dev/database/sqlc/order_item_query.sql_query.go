// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order_item_query.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const createOrderItem = `-- name: CreateOrderItem :execlastid
INSERT INTO
    order_items (
        order_id,
        item_id,
        quantity,
        price_per_item,
        total,
        original_price,
        is_sale,
        discount_amount,
        status,
        created_at,
        updated_at,
        item_name,
        category_name,
        modifiers,
        tax,
        note
    )
VALUES (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    )
`

type CreateOrderItemParams struct {
	OrderID        int32          `json:"orderId"`
	ItemID         string         `json:"itemId"`
	Quantity       float64        `json:"quantity"`
	PricePerItem   int32          `json:"pricePerItem"`
	Total          int32          `json:"total"`
	OriginalPrice  int32          `json:"originalPrice"`
	IsSale         bool           `json:"isSale"`
	DiscountAmount int32          `json:"discountAmount"`
	Status         string         `json:"status"`
	CreatedAt      sql.NullTime   `json:"createdAt"`
	UpdatedAt      sql.NullTime   `json:"updatedAt"`
	ItemName       string         `json:"itemName"`
	CategoryName   sql.NullString `json:"categoryName"`
	Modifiers      sql.NullString `json:"modifiers"`
	Tax            int32          `json:"tax"`
	Note           sql.NullString `json:"note"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg *CreateOrderItemParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createOrderItem,
		arg.OrderID,
		arg.ItemID,
		arg.Quantity,
		arg.PricePerItem,
		arg.Total,
		arg.OriginalPrice,
		arg.IsSale,
		arg.DiscountAmount,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ItemName,
		arg.CategoryName,
		arg.Modifiers,
		arg.Tax,
		arg.Note,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getAvailableOrderItems = `-- name: GetAvailableOrderItems :many
SELECT id, entity_id, delivery_platform_id, external_item_id, created_at, updated_at, plu, price, item_name, allergies, available, available_from
FROM entity_delivery_platform
WHERE
    external_item_id IN (/*SLICE:item_ids*/?)
    AND delivery_platform_id = ?
    AND available = 1
`

type GetAvailableOrderItemsParams struct {
	ItemIds            []string `json:"itemIds"`
	DeliveryPlatformID int32    `json:"deliveryPlatformId"`
}

func (q *Queries) GetAvailableOrderItems(ctx context.Context, arg *GetAvailableOrderItemsParams) ([]*EntityDeliveryPlatform, error) {
	query := getAvailableOrderItems
	var queryParams []interface{}
	if len(arg.ItemIds) > 0 {
		for _, v := range arg.ItemIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:item_ids*/?", strings.Repeat(",?", len(arg.ItemIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:item_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.DeliveryPlatformID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EntityDeliveryPlatform{}
	for rows.Next() {
		var i EntityDeliveryPlatform
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.DeliveryPlatformID,
			&i.ExternalItemID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Plu,
			&i.Price,
			&i.ItemName,
			&i.Allergies,
			&i.Available,
			&i.AvailableFrom,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
